<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pictures to PDF Generator</title>
<link rel="icon" href="https://raw.githubusercontent.com/pgarciafer/pics2PDF/main/logo1.png" type="image/png">
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>
<style>
/* ... (All CSS styles remain exactly the same as before) ... */
:root {
Â  --primary-color: #005A9C;
Â  --primary-hover: #004a80;
Â  --secondary-color: #6c757d;
Â  --secondary-hover: #5a6268;
Â  --danger-color: #dc3545;
Â  --danger-hover: #c82333;
Â  --success-color: #28a745;
Â  --bg-color: #f8f9fa;
Â  --container-bg: #ffffff;
Â  --text-color: #212529;
Â  --text-muted: #6c757d;
Â  --border-color: #dee2e6;
Â  --card-shadow: 0 4px 12px rgba(0,0,0,0.08);
Â  --input-focus-shadow: 0 0 0 0.25rem rgba(0, 90, 156, 0.25);
Â  --input-invalid-shadow: 0 0 0 0.25rem rgba(220, 53, 69, 0.25);
}

*, *::before, *::after {
Â  box-sizing: border-box;
}

body {
Â  font-family: Inter, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
Â  background-color: var(--bg-color);
Â  margin: 0;
Â  padding: 24px;
Â  display: flex;
Â  justify-content: center;
Â  align-items: flex-start;
Â  min-height: 100vh;
Â  color: var(--text-color);
}

.container {
Â  max-width: 800px;
Â  width: 100%;
Â  padding: 24px;
Â  background: var(--container-bg);
Â  border-radius: 8px;
Â  box-shadow: var(--card-shadow);
Â  border: 1px solid var(--border-color);
Â  transition: all 0.3s ease;
}

.header-container {
Â  display: flex;
Â  justify-content: center;
Â  align-items: center;
Â  margin-bottom: 32px;
Â  padding-bottom: 10px;
Â  border-bottom: 1px solid var(--border-color);
}

.header-title {
Â  display: flex;
Â  align-items: center;
Â  gap: 16px;
}

.header-title img {
Â  height: 60px;
}

.header-title span {
Â  font-size: 20px;
Â  font-weight: 600;
Â  color: var(--primary-color);
Â  letter-spacing: -0.5px;
}

label {
Â  display: block;
Â  margin-top: 16px;
Â  margin-bottom: 8px;
Â  font-weight: 500;
Â  color: var(--text-muted);
Â  font-size: 14px;
}

input, select {
Â  width: 100%;
Â  padding: 10px;
Â  border-radius: 6px;
Â  border: 1px solid var(--border-color);
Â  font-size: 15px;
Â  transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
Â  background-color: #fff;
Â  color: var(--text-color);
}

input:focus, select:focus {
Â  outline: none;
Â  border-color: var(--primary-color);
Â  box-shadow: var(--input-focus-shadow);
}

.drop-zone-section {
Â  display: grid;
Â  grid-template-columns: 1fr auto;
Â  gap: 16px;
Â  align-items: stretch;
Â  margin-bottom: 16px;
}

.drop-zone {
Â  border: 2px dashed var(--border-color);
Â  background: #fafcff;
Â  padding: 20px;
Â  text-align: center;
Â  cursor: pointer;
Â  border-radius: 12px;
Â  transition: all 0.3s;
Â  display: flex;
Â  flex-direction: column;
Â  align-items: center;
Â  justify-content: center;
Â  min-height: 120px;
}

.drop-zone:hover, .drop-zone.dragover {
Â  border-color: var(--primary-color);
Â  background: #f0f6ff;
}

/* Style for keyboard focus */
.drop-zone:focus {
Â  outline: none;
Â  border-color: var(--primary-color);
Â  box-shadow: var(--input-focus-shadow);
}

.drop-zone p {
Â  font-size: 16px;
Â  font-weight: 500;
Â  color: var(--text-muted);
Â  margin: 0;
}

.image-list-container, .attachment-list-container {
Â  border: 1px solid var(--border-color);
Â  min-height: 100px;
Â  max-height: 200px;
Â  overflow-y: auto;
Â  padding: 16px;
Â  border-radius: 12px;
Â  background: #f8f9fa;
Â  display: none;
Â  gap: 12px;
}

.image-list-container {
Â  display: none;
Â  flex-wrap: wrap;
}

.image-wrapper {
Â  position: relative;
Â  -webkit-user-select: none; /* Safari */
Â  -ms-user-select: none; /* IE 10+ */
Â  user-select: none;
}

.image-item {
Â  width: 70px;
Â  height: 70px;
Â  object-fit: cover;
Â  border: 2px solid var(--border-color);
Â  border-radius: 8px;
Â  padding: 4px;
Â  background: #fff;
Â  cursor: pointer;
Â  transition: transform 0.2s, box-shadow 0.2s;
}
.image-item:hover {
Â  transform: scale(1.05);
Â  box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
.image-wrapper.dragging {
Â  opacity: 0.5;
}
.image-wrapper.over {
Â  outline: 2px dashed var(--primary-color);
Â  outline-offset: 2px;
}

.remove-image-btn {
Â  position: absolute;
Â  top: -8px;
Â  right: -8px;
Â  background: var(--danger-color);
Â  color: white;
Â  border: 2px solid white;
Â  border-radius: 50%;
Â  width: 24px;
Â  height: 24px;
Â  font-size: 16px;
Â  line-height: 1;
Â  display: flex;
Â  align-items: center;
Â  justify-content: center;
Â  cursor: pointer;
Â  opacity: 0.9;
Â  transition: all 0.3s;
Â  z-index: 10;
}

.remove-image-btn:hover {
Â  opacity: 1;
Â  transform: scale(1.1);
Â  background-color: var(--danger-hover);
}

.attachment-list-container {
Â  display: none;
}
.attachment-item {
Â  font-size: 14px;
Â  color: var(--text-color);
Â  padding: 8px 4px;
Â  border-bottom: 1px solid var(--border-color);
}
.attachment-item:last-child {
Â  border-bottom: none;
}

.button-group {
Â  margin-top: 32px;
}

button {
Â  padding: 10px 16px;
Â  border: 1px solid transparent;
Â  border-radius: 6px;
Â  cursor: pointer;
Â  font-size: 15px;
Â  font-weight: 500;
Â  transition: background-color 0.15s ease-in-out, transform 0.1s ease;
Â  position: relative;
Â  -webkit-appearance: none;
}

button:disabled {
Â  background-color: #ccc;
Â  cursor: not-allowed;
Â  transform: none;
Â  opacity: 0.7;
}

button:active:not(:disabled) {
Â  transform: scale(0.98);
}


#generatePDF {
Â  width: 100%;
Â  background-color: var(--primary-color);
Â  color: white;
Â  font-size: 16px;
Â  font-weight: 600;
}

#generatePDF:hover:not(:disabled) {
Â  background-color: var(--primary-hover);
}

#generatePDF.loading span {
Â  visibility: hidden;
}
#generatePDF.loading::after {
Â  content: '';
Â  position: absolute;
Â  width: 24px;
Â  height: 24px;
Â  top: 0;
Â  left: 0;
Â  right: 0;
Â  bottom: 0;
Â  margin: auto;
Â  border: 4px solid transparent;
Â  border-top-color: #ffffff;
Â  border-radius: 50%;
Â  animation: button-loading-spinner 1s ease infinite;
}
@keyframes button-loading-spinner {
Â  from { transform: rotate(0turn); }
Â  to { transform: rotate(1turn); }
}

/* === NEW CSS FOR BUTTONS === */
.job-info-buttons {
Â  display: flex;
Â  gap: 16px;
Â  margin-bottom: 24px;
}

.job-info-btn {
Â  width: 100%;
Â  background-color: var(--primary-color);
Â  color: white;
}
.job-info-btn:hover:not(:disabled) {
Â  background-color: var(--primary-hover);
}

/* Style for the new save button */
.job-info-btn.save {
Â  background-color: var(--secondary-color);
}
.job-info-btn.save:hover:not(:disabled) {
Â  background-color: var(--secondary-hover);
}
/* === END NEW CSS === */


.required-label {
Â  color: var(--danger-color);
Â  font-weight: 600;
}

.invalid {
Â  border-color: var(--danger-color) !important;
Â  box-shadow: var(--input-invalid-shadow) !important;
}

.status-message {
Â  text-align: center;
Â  margin-top: 20px;
Â  padding: 12px;
Â  border-radius: 8px;
Â  font-size: 14px;
Â  font-weight: 500;
Â  display: none;
}
.status-message.visible {
Â  Â  display: block;
}
.status-message.success {
Â  background-color: #e9f7ef;
Â  color: #155724;
}
.status-message.error {
Â  background-color: #f8d7da;
Â  color: #721c24;
}
.status-message.info {
Â  background-color: rgba(0, 90, 156, 0.1);
Â  color: var(--primary-color);
}

button.remove-btn {
Â  background-color: white;
Â  color: var(--danger-color);
Â  height: 100%;
Â  border: 1px solid var(--danger-color);
Â  width: 210px;
}
button.remove-btn:hover:not(:disabled) {
Â  background-color: var(--danger-color);
Â  color: white;
}

.attachment-section {
Â  margin-top: 32px;
}

#dateField {
Â  width: 75%;
}

.modal-overlay {
Â  position: fixed;
Â  top: 0;
Â  left: 0;
Â  width: 100%;
Â  height: 100%;
Â  background: rgba(0,0,0,0.6);
Â  display: flex;
Â  justify-content: center;
Â  align-items: center;
Â  z-index: 1000;
}
.modal-content {
Â  background: white;
Â  padding: 24px;
Â  border-radius: 8px;
Â  width: 90%;
Â  max-width: 500px;
Â  box-shadow: 0 5px 15px rgba(0,0,0,0.3);
}
.modal-content h2 {
Â  margin-top: 0;
Â  color: var(--primary-color);
}
.modal-content textarea {
Â  width: 100%;
Â  padding: 10px;
Â  border-radius: 6px;
Â  border: 1px solid var(--border-color);
Â  font-size: 15px;
Â  resize: vertical;
Â  margin-bottom: 16px;
}
.modal-content textarea:focus {
Â  outline: none;
Â  border-color: var(--primary-color);
Â  box-shadow: var(--input-focus-shadow);
}
.modal-buttons {
Â  display: flex;
Â  justify-content: flex-end;
Â  gap: 12px;
}
.modal-buttons button {
Â  padding: 10px 16px;
}
#modalSaveBtn {
Â  background-color: var(--primary-color);
Â  color: white;
}
#modalSaveBtn:hover {
Â  background-color: var(--primary-hover);
}
#modalDeleteBtn {
Â  background-color: var(--danger-color);
Â  color: white;
Â  border: none;
}
#modalDeleteBtn:hover {
Â  background-color: var(--danger-hover);
}
#modalCancelBtn {
Â  background-color: var(--secondary-color);
Â  color: white;
}
#modalCancelBtn:hover {
Â  background-color: var(--secondary-hover);
}

.comment-icon {
Â  position: absolute;
Â  bottom: 2px;
Â  left: 2px;
Â  font-size: 18px;
Â  display: none; /* Hidden by default */
Â  pointer-events: none; /* So it doesn't interfere with clicks on the image */
Â  text-shadow: 0 0 3px white, 0 0 3px white;
}
.comment-icon.visible {
Â  display: block;
}

.checkbox-container {
Â  display: flex;
Â  align-items: center;
Â  margin-top: 24px;
Â  margin-bottom: -16px; /* Pull the button group up */
Â  padding: 12px;
Â  background-color: #f8f9fa;
Â  border-radius: 6px;
Â  border: 1px solid var(--border-color);
}
.checkbox-container input[type="checkbox"] {
Â  width: auto;
Â  margin-right: 12px;
Â  transform: scale(1.2);
Â  cursor: pointer;
}
.checkbox-container label {
Â  margin: 0;
Â  font-weight: 500;
Â  color: var(--text-color);
Â  font-size: 14px;
Â  cursor: pointer;
}


/* Responsive */
@media (max-width: 768px) {
Â  body {
Â  Â  padding: 16px;
Â  }
Â  .container {
Â  Â  padding: 24px;
Â  }
Â  .header-container {
Â  Â  flex-direction: column;
Â  Â  gap: 16px;
Â  }
Â  .header-title {
Â  Â  flex-direction: column;
Â  }
}
@media (max-width: 600px) {
Â  .drop-zone-section {
Â  Â  grid-template-columns: 1fr;
Â  }
Â  button.remove-btn {
Â  Â  min-height: 60px;
Â  Â  width: 100%;
Â  }
Â  /* === NEW: Stack buttons on mobile === */
Â  .job-info-buttons {
Â  Â  flex-direction: column;
Â  }
}

/* Styles for touch-based drag and drop */
.image-wrapper.touch-dragging {
Â  opacity: 0.8;
Â  transform-origin: center center;
Â  box-shadow: 0 8px 20px rgba(0,0,0,0.2);
Â  z-index: 1000;
Â  transition: none; /* Disable transitions while dragging */
}
.placeholder {
Â  background-color: #e9ecef;
Â  border: 2px dashed var(--primary-color);
Â  border-radius: 8px;
Â  flex-shrink: 0;
Â  /* width and height set by JS */
}
</style>
</head>
<body>
<div class="container">
<div class="header-container">
Â  <div class="header-title">
Â  Â  <a href="https://www.mtnsat.com" target="_blank">
Â  Â  Â  <img src="https://raw.githubusercontent.com/pgarciafer/pics2PDF/main/logo.png" alt="Logo">
Â  Â  </a>
Â  Â  <span>Pictures Array to PDF</span>
Â  </div>
</div>

<div class="job-info-buttons">
Â  <button id="loadJobInfoBtn" class="job-info-btn">Load Job Info (.txt)</button>
Â  <button id="saveJobInfoBtn" class="job-info-btn save">Save Job Info (.txt)</button>
</div>
<div class="drop-zone-section">
Â  <div class="drop-zone" id="dropZone" tabindex="0">
Â  Â  <p>ğŸ“ Drag & Drop Pictures Here or Click</p>
Â  </div>
Â  <button id="removeAllBtn" class="remove-btn">Remove All Images</button>
</div>
<div class="image-list-container" id="imageListContainer"></div>


<div class="attachment-section">
Â  <div class="drop-zone-section">
Â  Â  <div class="drop-zone" id="attachmentsDropZone" tabindex="0">
Â  Â  Â  <p>ğŸ“ Drag & Drop Attachments Here or Click</p>
Â  Â  </div>
Â  Â  <button id="removeAllAttachmentsBtn" class="remove-btn">Remove All Attachments</button>
Â  </div>
Â  <div class="attachment-list-container" id="attachmentListContainer"></div>
</div>

<label for="vesselName">3LC_VesselName: <span class="required-label">*</span></label>
<input type="text" id="vesselName" placeholder="e.g., NCL_RoyalClipper">

<label for="antennaModel">AntennaBrandModel_SNxxx: <span class="required-label">*</span></label>
<input type="text" id="antennaModel" placeholder="e.g., Intellian-v100_SN24536">

<label for="antennaLocation">Antenna Location: <span class="required-label">*</span></label>
<input type="text" id="antennaLocation" placeholder="e.g., Deck 1 Starboard">

<label for="caseNumber">Case Number: <span class="required-label">*</span></label>
<input type="tel" id="caseNumber" inputmode="numeric" pattern="[0-9]*" placeholder="e.g., 35234">

<label for="submittedBy">Submitted By: <span class="required-label">*</span></label>
<input type="text" id="submittedBy" placeholder="e.g., Pablo Garcia">

<label for="dateField">Date: <span class="required-label">*</span></label>
<input type="date" id="dateField">

<label for="imagesPerPage">Images per page (1-4):</label>
<select id="imagesPerPage">
Â  <option value="1">1</option>
Â  <option value="2" selected>2</option>
Â  <option value="3">3</option>
Â  <option value="4">4</option>
</select>

<label for="compressionLevel">Image Quality:</label>
<select id="compressionLevel">
Â  <option value="0.9">Best (Larger File Size)</option>
Â  <option value="0.7" selected>Good (Recommended)</option>
Â  <option value="0.5">Standard (Smallest File Size)</option>
</select>

<div class="checkbox-container">
Â  <input type="checkbox" id="compressPdf">
Â  <label for="compressPdf">Compress PDF with iLovePDF (Online)</label>
</div>

<div class="button-group">
Â  <button id="generatePDF"><span>Generate PDF & ZIP</span></button>
</div>

<div class="status-message" id="statusMessage"></div>
</div>

<div id="imageModal" class="modal-overlay" style="display: none;">
Â  <div class="modal-content">
Â  Â  <h2>Edit Image</h2>
Â  Â  <label for="imageComment">Comment:</label>
Â  Â  <textarea id="imageComment" rows="4" placeholder="Add a comment to display under the image in the PDF..."></textarea>
Â  Â  <div class="modal-buttons">
Â  Â  Â  <button id="modalSaveBtn">Save Comment</button>
Â  Â  Â  <button id="modalDeleteBtn" class="remove-btn" style="border: 1px solid transparent; color: white;">Delete Image</button>
Â  Â  Â  <button id="modalCancelBtn">Cancel</button>
Â  Â  </div>
Â  </div>
</div>

<script>
const { jsPDF } = window.jspdf;

// --- IMPORTANT ---
// PASTE YOUR ILOVEPDF PUBLIC KEY HERE
// You can get a free key from: https://developer.ilovepdf.com/
const ILOVEPDF_PUBLIC_KEY = 'project_public_45717f2112c002ca935583d7bb839134_IKjet4326dd7221e73fb14f7a5f97819300d2';

let images = [];
let attachments = [];
let dragSrcEl = null; // for desktop drag and drop reordering
const dropZone = document.getElementById('dropZone');
const imageListContainer = document.getElementById('imageListContainer');
const attachmentsDropZone = document.getElementById('attachmentsDropZone');
const attachmentListContainer = document.getElementById('attachmentListContainer');
const generateBtn = document.getElementById('generatePDF');
const statusMessage = document.getElementById('statusMessage');

// === NEW: Button and LocalStorage variables ===
const loadJobInfoBtn = document.getElementById('loadJobInfoBtn');
const saveJobInfoBtn = document.getElementById('saveJobInfoBtn');
const jobInfoInputIds = ["vesselName", "antennaModel", "antennaLocation", "caseNumber", "submittedBy"];
// === END NEW ===

// Modal elements
const imageModal = document.getElementById('imageModal');
const imageCommentTextarea = document.getElementById('imageComment');
const modalSaveBtn = document.getElementById('modalSaveBtn');
const modalDeleteBtn = document.getElementById('modalDeleteBtn');
const modalCancelBtn = document.getElementById('modalCancelBtn');
let activeImageIndex = -1;


// Default date
document.getElementById("dateField").value = new Date().toISOString().split("T")[0];

// Add listeners for keyboard interaction
function setupDropZoneAccessibility(zoneId) {
Â  const zone = document.getElementById(zoneId);
Â  zone.addEventListener('keydown', (e) => {
Â  Â  // 32 = Space, 13 = Enter
Â  Â  if (e.keyCode === 32 || e.keyCode === 13) {
Â  Â  Â  e.preventDefault(); // Stop space from scrolling the page
Â  Â  Â  zone.click(); // Trigger the existing click listener
Â  Â  }
Â  });
}
setupDropZoneAccessibility('dropZone');
setupDropZoneAccessibility('attachmentsDropZone');


function showStatus(message, type = 'info') {
Â  Â  statusMessage.textContent = message;
Â  Â  statusMessage.className = `status-message ${type} visible`;
}

// Helper function to convert any image file (including HEIC) to a JPG data URL
async function convertImageToJpgDataUrl(file, maxPreviewDim = 300, quality = 0.8) {
Â  return new Promise((resolve, reject) => {
Â  Â  // createImageBitmap is the most memory-efficient way to load an image
Â  Â  createImageBitmap(file)
Â  Â  Â  .then(imageBitmap => {
Â  Â  Â  Â  // Calculate dimensions for a small preview
Â  Â  Â  Â  const scale = Math.min(maxPreviewDim / imageBitmap.width, maxPreviewDim / imageBitmap.height, 1);
Â  Â  Â  Â  const canvas = document.createElement("canvas");
Â  Â  Â  Â  canvas.width = imageBitmap.width * scale;
Â  Â  Â  Â  canvas.height = imageBitmap.height * scale;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const ctx = canvas.getContext("2d");
Â  Â  Â  Â  // Draw the image to the canvas
Â  Â  Â  Â  ctx.drawImage(imageBitmap, 0, 0, canvas.width, canvas.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Good practice to release memory
Â  Â  Â  Â  imageBitmap.close();Â 
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Get the preview as a JPG data URL
Â  Â  Â  Â  const dataUrl = canvas.toDataURL("image/jpeg", quality);
Â  Â  Â  Â  resolve(dataUrl);
Â  Â  Â  })
Â  Â  Â  .catch(err => {
Â  Â  Â  Â  // Fallback for older browsers or formats createImageBitmap fails on
Â  Â  Â  Â  // This is less memory efficient but more compatible.
Â  Â  Â  Â  console.warn("createImageBitmap failed, falling back to FileReader:", err);
Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  reader.onload = (e) => {
Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  img.onload = () => {
Â  Â  Â  Â  Â  Â  const scale = Math.min(maxPreviewDim / img.width, maxPreviewDim / img.height, 1);
Â  Â  Â  Â  Â  Â  const canvas = document.createElement('canvas');
Â  Â  Â  Â  Â  Â  canvas.width = img.width * scale;
Â  Â  Â  Â  Â  Â  canvas.height = img.height * scale;
Â  Â  Â  Â  Â  Â  const ctx = canvas.getContext('2d');
Â  Â  Â  Â  Â  Â  ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
Â  Â  Â  Â  Â  Â  resolve(canvas.toDataURL('image/jpeg', quality));
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  img.onerror = reject;
Â  Â  Â  Â  Â  img.src = e.target.result;
Â  Â  Â  Â  };
Â  Â  Â  Â  reader.onerror = reject;
Â  Â  Â  Â  reader.readAsDataURL(file);
Â  Â  Â  });
Â  });
}


// Helpers
// New, more memory-efficient image processing function for PDF generation
async function processImageForPdf(file, maxDim = 2000, quality = 0.7) {
Â  return new Promise((resolve, reject) => {
Â  Â  // createImageBitmap is more memory-efficient than loading into an Image element via dataURL
Â  Â  createImageBitmap(file)
Â  Â  Â  .then(imageBitmap => {
Â  Â  Â  Â  const scale = Math.min(maxDim / imageBitmap.width, maxDim / imageBitmap.height, 1);
Â  Â  Â  Â  const canvas = document.createElement("canvas");
Â  Â  Â  Â  canvas.width = imageBitmap.width * scale;
Â  Â  Â  Â  canvas.height = imageBitmap.height * scale;
Â  Â  Â  Â  const ctx = canvas.getContext("2d");
Â  Â  Â  Â  ctx.drawImage(imageBitmap, 0, 0, canvas.width, canvas.height);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Close the bitmap to release its memory
Â  Â  Â  Â  imageBitmap.close();

Â  Â  Â  Â  canvas.toBlob(blob => {
Â  Â  Â  Â  Â  if (!blob) {
Â  Â  Â  Â  Â  Â  return reject(new Error("Canvas to Blob conversion failed."));
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  const reader = new FileReader();
Â  Â  Â  Â  Â  reader.onload = () => resolve(reader.result);
Â  Â  Â  Â  Â  reader.onerror = () => reject(new Error("Failed to read blob as Data URL."));
Â  Â  Â  Â  Â  reader.readAsDataURL(blob);
Â  Â  Â  Â  }, "image/jpeg", quality);
Â  Â  Â  })
Â  Â  Â  .catch(err => reject(err));
Â  });
}

function formatVesselName(raw) {
Â  if (!raw) return "";
Â  let clean = raw.replace(/_/g, " ").replace(/\s+/g, " ").trim();
Â  let firstThree = clean.slice(0,3).toUpperCase();
Â  let rest = clean.slice(3).trim();
Â  if (!rest) return firstThree;
Â  let words = rest.split(" ").map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase());
Â  let formattedRest = words.join("");
Â  return firstThree + "_" + formattedRest;
}

function formatAntennaModel(model, sn) {
Â  if (!model || !sn) return "";
Â  let m = model.trim().replace(/\s+/g, "-");
Â  return (m.charAt(0).toUpperCase() + m.slice(1)) + "_SN" + sn.trim().toUpperCase();
}

function formatAntennaLocation(loc) {
Â  if (!loc) return "";
Â  return loc.trim().toUpperCase();
}

function formatSubmittedby(name) {
Â  if (!name) return "";
Â  return name
Â  Â  .trim()
Â  Â  .split(/\s+/)
Â  Â  .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
Â  Â  .join(" ");
}

let jobFileHandle = null;

// === RENAMED: from "jobInfoLabel" to "loadJobInfoBtn" ===
loadJobInfoBtn.addEventListener("click", async () => {
Â  const openWithInput = () => {
Â  Â  const fileInput = document.createElement('input');
Â  Â  fileInput.type = 'file';
Â  Â  fileInput.accept = '.txt';
Â  Â  fileInput.onchange = async () => {
Â  Â  Â  if (!fileInput.files || fileInput.files.length === 0) return;
Â  Â  Â  const file = fileInput.files[0];
Â  Â  Â  try {
Â  Â  Â  Â  Â  const text = await file.text();
Â  Â  Â  Â  Â  const data = JSON.parse(text);
Â  Â  Â  Â  Â  populateJobInfo(data);
Â  Â  Â  Â  Â  // === NEW: Save loaded data to local storage ===
Â  Â  Â  Â  Â  saveFormToLocalStorage();
Â  Â  Â  } catch (err) {
Â  Â  Â  Â  Â  console.error(err);
Â  Â  Â  Â  Â  showStatus("Failed to process job info file.", "error");
Â  Â  Â  }
Â  Â  };
Â  Â  fileInput.click();
Â  };

Â  try {
Â  Â  if (!window.showOpenFilePicker) {
Â  Â  Â  Â  throw new Error("showOpenFilePicker not supported");
Â  Â  }

Â  Â  if (!jobFileHandle) {
Â  Â  Â  [jobFileHandle] = await window.showOpenFilePicker({
Â  Â  Â  Â  types: [{
Â  Â  Â  Â  Â  description: 'Job Info File',
Â  Â  Â  Â  Â  accept: { 'text/plain': ['.txt'] },
Â  Â  Â  Â  }],
Â  Â  Â  Â  multiple: false
Â  Â  Â  });
Â  Â  }
Â  Â  const file = await jobFileHandle.getFile();
Â  Â  const text = await file.text();
Â  Â  const data = JSON.parse(text);
Â  Â  populateJobInfo(data);
Â  Â  // === NEW: Save loaded data to local storage ===
Â  Â  saveFormToLocalStorage();

Â  } catch (err) {
Â  Â  if (err.name === 'AbortError') {
Â  Â  Â  console.log('File picker was cancelled by the user.');
Â  Â  Â  return;
Â  Â  }
Â  Â  console.warn("showOpenFilePicker failed, falling back to input.", err);
Â  Â  openWithInput();
Â  }
});

function populateJobInfo(data) {
Â  if (data.VESSEL) document.getElementById("vesselName").value = formatVesselName(data.VESSEL);
Â  if (data.INCIDENT) document.getElementById("caseNumber").value = data.INCIDENT;
Â  if (data["ANTENNA"] && data["ANTENNA SN"]) {
Â  Â  document.getElementById("antennaModel").value = formatAntennaModel(data["ANTENNA"], data["ANTENNA SN"]);
Â  }
Â  if (data["LOCATION"]) document.getElementById("antennaLocation").value = formatAntennaLocation(data["LOCATION"]);
Â  if (data["TECH"]) document.getElementById("submittedBy").value = formatSubmittedby(data["TECH"]);
Â  showStatus("Current Job Info loaded successfully!", "success");
}

// === NEW: "Save Job Info" Button functionality ===
saveJobInfoBtn.addEventListener('click', () => {
Â  const data = {};
Â  jobInfoInputIds.forEach(id => {
Â  Â  data[id] = document.getElementById(id).value;
Â  });

Â  // Create a JSON object in the same format that "Load" expects
Â  const cleanData = {
Â  Â  "VESSEL": data.vesselName,
Â  Â  // Try to split model and SN, fallback to empty string
Â  Â  "ANTENNA": (data.antennaModel.split('_SN')[0] || data.antennaModel).split('_')[0],
Â  Â  "ANTENNA SN": data.antennaModel.split('_SN')[1] || '',
Â  Â  "LOCATION": data.antennaLocation,
Â  Â  "INCIDENT": data.caseNumber,
Â  Â  "TECH": data.submittedBy
Â  };

Â  const jsonString = JSON.stringify(cleanData, null, 2); // Pretty-print JSON
Â  const blob = new Blob([jsonString], { type: 'text/plain;charset=utf-8' });
Â Â 
Â  // === THIS IS THE REQUESTED CHANGE ===
Â  const filename = 'currentrip.txt';

Â  saveAs(blob, filename); // From FileSaver.js
Â  showStatus('Job info saved as currentrip.txt!', 'success');
Â  // === END OF CHANGE ===
});

// === NEW: LocalStorage Functions ===
function saveFormToLocalStorage() {
Â  const data = {};
Â  jobInfoInputIds.forEach(id => {
Â  Â  data[id] = document.getElementById(id).value;
Â  });
Â  localStorage.setItem('jobInfoForm', JSON.stringify(data));
}

function loadFormFromLocalStorage() {
Â  const savedData = localStorage.getItem('jobInfoForm');
Â  if (savedData) {
Â  Â  try {
Â  Â  Â  const data = JSON.parse(savedData);
Â  Â  Â  jobInfoInputIds.forEach(id => {
Â  Â  Â  Â  if (data[id]) {
Â  Â  Â  Â  Â  document.getElementById(id).value = data[id];
Â  Â  Â  Â  }
Â  Â  Â  });
Â  Â  } catch (e) {
Â  Â  Â  console.error("Failed to parse saved job info:", e);
Â  Â  Â  localStorage.removeItem('jobInfoForm'); // Clear corrupted data
Â  Â  }
Â  }
}
// === END NEW ===


dropZone.addEventListener('click', () => {
Â  const fileInput = document.createElement('input');
Â  fileInput.type = 'file';
Â  fileInput.multiple = true;
Â  fileInput.accept = 'image/jpeg,image/png,image/heif,image/heic';
Â  fileInput.onchange = () => addImages(fileInput.files);
Â  fileInput.click();
});
dropZone.addEventListener('dragover', e => { e.preventDefault(); dropZone.classList.add("dragover"); });
dropZone.addEventListener('dragleave', e => { e.preventDefault(); dropZone.classList.remove("dragover"); });
dropZone.addEventListener('drop', e => { e.preventDefault(); dropZone.classList.remove("dragover"); addImages(e.dataTransfer.files); });

// Asynchronous image loading
async function addImages(fileList) {
Â  if (fileList.length > 0) imageListContainer.style.display = 'flex';
Â Â 
Â  const filesToProcess = Array.from(fileList).filter(file => file.type.startsWith('image/'));
Â Â 
Â  // Show a status update and disable button
Â  showStatus(`Processing ${filesToProcess.length} images...`, 'info');
Â  generateBtn.disabled = true;

Â  for (let i = 0; i < filesToProcess.length; i++) {
Â  Â  const file = filesToProcess[i];
Â  Â  // Update status for every image
Â  Â  statusMessage.textContent = `Processing image ${i + 1} of ${filesToProcess.length}...`;

Â  Â  try {
Â  Â  Â  const previewDataUrl = await convertImageToJpgDataUrl(file);

Â  Â  Â  const wrapper = document.createElement('div');
Â  Â  Â  wrapper.classList.add('image-wrapper');
Â  Â  Â  wrapper.draggable = true;
Â  Â  Â Â 
Â  Â  Â  const previewImg = document.createElement('img');
Â  Â  Â  previewImg.src = previewDataUrl;Â 
Â  Â  Â  previewImg.classList.add('image-item');

Â  Â  Â  previewImg.onclick = () => {
Â  Â  Â  Â  const index = Array.from(imageListContainer.children).indexOf(wrapper);
Â  Â  Â  Â  openImageModal(index);
Â  Â  Â  };
Â  Â  Â Â 
Â  Â  Â  const removeBtn = document.createElement('button');
Â  Â  Â  removeBtn.innerHTML = "Ã—";
Â  Â  Â  removeBtn.classList.add('remove-image-btn');
Â  Â  Â  removeBtn.ariaLabel = "Remove image";Â 
Â  Â  Â Â 
Â  Â  Â  removeBtn.onclick = () => {
Â  Â  Â  Â  const index = Array.from(imageListContainer.children).indexOf(wrapper);
Â  Â  Â  Â  if (index > -1) {
Â  Â  Â  Â  Â  Â  images.splice(index, 1);
Â  Â  Â  Â  Â  Â  wrapper.remove();
Â  Â  Â  Â  Â  Â  if (images.length === 0) imageListContainer.style.display = 'none';
Â  Â  Â  Â  }
Â  Â  Â  };

Â  Â  Â  const commentIcon = document.createElement('span');
Â  Â  Â  commentIcon.classList.add('comment-icon');
Â  Â  Â  commentIcon.textContent = 'ğŸ’¬';
Â  Â  Â Â 
Â  Â  Â  wrapper.appendChild(previewImg);
Â  Â  Â  wrapper.appendChild(removeBtn);
Â  Â  Â  wrapper.appendChild(commentIcon);
Â  Â  Â  imageListContainer.appendChild(wrapper);

Â  Â  Â  const newImageData = {
Â  Â  Â  Â  Â  file: file, // Store the ORIGINAL file (HEIC or JPG)
Â  Â  Â  Â  Â  comment: '',
Â  Â  Â  Â  Â  id: 'img-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9)
Â  Â  Â  };
Â  Â  Â  images.push(newImageData);
Â  Â  Â  wrapper.dataset.id = newImageData.id;

Â  Â  Â  wrapper.addEventListener('dragstart', handleDragStart, false);
Â  Â  Â  wrapper.addEventListener('dragenter', handleDragEnter, false);
Â  Â  Â  wrapper.addEventListener('dragover', handleDragOver, false);
Â  Â  Â  wrapper.addEventListener('dragleave', handleDragLeave, false);
Â  Â  Â  wrapper.addEventListener('drop', handleDrop, false);
Â  Â  Â  wrapper.addEventListener('dragend', handleDragEnd, false);
Â  Â  Â  wrapper.addEventListener('touchstart', handleTouchStart, { passive: true });

Â  Â  Â  // After each image, pause briefly to let the UI update
Â  Â  Â  await new Promise(res => setTimeout(res, 0));Â 

Â  Â  } catch (err) {
Â  Â  Â  Â  console.error("Failed to process image:", file.name, err);
Â  Â  Â  Â  showStatus(`Failed to load image: ${file.name}.`, "error");
Â  Â  }
Â  }

Â  // Done! Re-enable button
Â  showStatus(`Added ${filesToProcess.length} images. Hint: Long-press to re-order.`, 'success');
Â  generateBtn.disabled = false;
}

document.getElementById('removeAllBtn').addEventListener('click', () => {
Â  images = [];
Â  imageListContainer.innerHTML = '';
Â  imageListContainer.style.display = 'none';
Â  showStatus('All images removed.', 'info');
});

// Modal Functions
function openImageModal(index) {
Â  if (index < 0 || index >= images.length) return;
Â  activeImageIndex = index;
Â  imageCommentTextarea.value = images[index].comment;
Â  imageModal.style.display = 'flex';
Â  imageCommentTextarea.focus();
}

function closeImageModal() {
Â  imageModal.style.display = 'none';
Â  activeImageIndex = -1;
Â  imageCommentTextarea.value = '';
}

modalSaveBtn.addEventListener('click', () => {
Â  if (activeImageIndex > -1) {
Â  Â  const imageData = images[activeImageIndex];
Â  Â  imageData.comment = imageCommentTextarea.value.trim();
Â  Â Â 
Â  Â  const wrapper = imageListContainer.children[activeImageIndex];
Â  Â  if (wrapper) {
Â  Â  Â  Â  const commentIcon = wrapper.querySelector('.comment-icon');
Â  Â  Â  Â  if (imageData.comment) {
Â  Â  Â  Â  Â  commentIcon.classList.add('visible');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  commentIcon.classList.remove('visible');
Â  Â  Â  Â  }
Â  Â  }
Â  }
Â  closeImageModal();
});

modalDeleteBtn.addEventListener('click', () => {
Â  Â  if (activeImageIndex > -1) {
Â  Â  Â  Â  const wrapper = imageListContainer.children[activeImageIndex];
Â  Â  Â  Â  if (wrapper) {
Â  Â  Â  Â  Â  Â  images.splice(activeImageIndex, 1);
Â  Â  Â  Â  Â  Â  wrapper.remove();
Â  Â  Â  Â  Â  Â  if (images.length === 0) imageListContainer.style.display = 'none';
Â  Â  Â  Â  }
Â  Â  }
Â  Â  closeImageModal();
});

modalCancelBtn.addEventListener('click', closeImageModal);
imageModal.addEventListener('click', (e) => {
Â  Â  if (e.target === imageModal) closeImageModal();
});


attachmentsDropZone.addEventListener('click', () => {
Â  const fileInput = document.createElement('input');
Â  fileInput.type = 'file';
Â  fileInput.multiple = true;
Â  // No 'accept' attribute here, to allow any file type as an attachment
Â  fileInput.onchange = () => addAttachments(fileInput.files);
Â  fileInput.click();
});
attachmentsDropZone.addEventListener('dragover', e => { e.preventDefault(); attachmentsDropZone.classList.add("dragover"); });
attachmentsDropZone.addEventListener('dragleave', e => { e.preventDefault(); attachmentsDropZone.classList.remove("dragover"); });
attachmentsDropZone.addEventListener('drop', e => { e.preventDefault(); attachmentsDropZone.classList.remove("dragover"); addAttachments(e.dataTransfer.files); });

function addAttachments(fileList){
Â  if(fileList.length > 0) attachmentListContainer.style.display = 'block';
Â  Array.from(fileList).forEach(file => {
Â  Â  attachments.push(file);
Â  Â  const item = document.createElement('div');
Â  Â  item.textContent = file.name;
Â  Â  item.classList.add('attachment-item');
Â  Â  attachmentListContainer.appendChild(item);
Â  });
}
document.getElementById('removeAllAttachmentsBtn').addEventListener('click', () => {
Â  attachments = [];
Â  attachmentListContainer.innerHTML = '';
Â  attachmentListContainer.style.display = 'none';
Â  showStatus('All attachments removed.', 'info');
});

async function compressPdfWithILovePdf(pdfBlob, publicKey) {
Â  Â  const authUrl = 'https://api.ilovepdf.com/v1/auth';
Â  Â  const startUrl = 'https://api.ilovepdf.com/v1/start/compress';

Â  Â  // 1. Authenticate
Â  Â  showStatus('Authenticating with compression service...', 'info');
Â  Â  const authResponse = await fetch(authUrl, {
Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  headers: { 'Content-Type': 'application/json' },
Â  Â  Â  Â  body: JSON.stringify({ public_key: publicKey })
Â  Â  });
Â  Â  if (!authResponse.ok) throw new Error(`iLovePDF authentication failed (${authResponse.status})`);
Â  Â  const { token } = await authResponse.json();
Â  Â  const authHeader = { 'Authorization': `Bearer ${token}` };

Â  Â  // 2. Start Task
Â  Â  showStatus('Starting compression task...', 'info');
Â  Â  const startResponse = await fetch(startUrl, { headers: authHeader });
Â  Â  if (!startResponse.ok) throw new Error('Failed to start iLovePDF task.');
Â  Â  const { server, task } = await startResponse.json();

Â  Â  // Use the dynamic server for all subsequent calls for this task
Â  Â  const uploadUrl = `https://${server}/v1/upload`;
Â  Â  const processUrl = `https://${server}/v1/process`;
Â  Â  const downloadUrl = `https://${server}/v1/download`;

Â  Â  // 3. Upload File
Â  Â  showStatus('Uploading PDF for compression...', 'info');
Â  Â  const formData = new FormData();
Â  Â  formData.append('task', task);
Â  Â  formData.append('file', pdfBlob, 'document.pdf');
Â  Â  const uploadResponse = await fetch(uploadUrl, {
Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  headers: authHeader,
Â  Â  Â  Â  body: formData
Â  Â  });
Â  Â  if (!uploadResponse.ok) throw new Error('Failed to upload file to iLovePDF.');
Â  Â  const { server_filename } = await uploadResponse.json();

Â  Â  // 4. Process File
Â  Â  showStatus('Compressing PDF...', 'info');
Â  Â  const processBody = {
Â  Â  Â  Â  task: task,
Â  Â  Â  Â  tool: 'compress',
Â  Â  Â  Â  files: [{ server_filename: server_filename, filename: 'document.pdf' }],
Â  Â  Â  Â  compression_level: 'recommended',
Â  Â  };
Â  Â  const processResponse = await fetch(processUrl, {
Â  Â  Â  Â  method: 'POST',
Â  Â  Â  Â  headers: { ...authHeader, 'Content-Type': 'application/json' },
Â  Â  Â  Â  body: JSON.stringify(processBody)
Â  Â  });
Â  Â  if (!processResponse.ok) throw new Error('Failed to process file with iLovePDF.');
Â  Â Â 
Â  Â  // 5. Download File
Â  Â  showStatus('Downloading compressed PDF...', 'info');
Â  Â  const downloadResponse = await fetch(`${downloadUrl}/${task}`, { headers: authHeader });
sÂ  Â  if (!downloadResponse.ok) throw new Error('Failed to download compressed file from iLovePDF.');
Â  Â Â 
Â  Â  return downloadResponse.blob();
}

generateBtn.addEventListener('click', async () => {
Â  statusMessage.className = 'status-message';
Â  generateBtn.disabled = true;
Â  generateBtn.classList.add('loading');

Â  try {
Â  Â  const requiredIds = ["vesselName", "antennaModel", "antennaLocation", "caseNumber", "submittedBy", "dateField"];
Â  Â  let valid = true;
Â  Â  requiredIds.forEach(id => {
Â  Â  Â  const f = document.getElementById(id);
Â  Â  Â  if (!f.value.trim()) {
Â  Â  Â  Â  f.classList.add("invalid");
Â  Â  Â  Â  valid = false;
Â  Â  Â  } else {
Â  Â  Â  Â  f.classList.remove("invalid");
Â  Â  Â  }
Â  Â  });
Â  Â  if (!valid) throw new Error("Please fill all required fields!");

Â  Â  if (images.length === 0 && attachments.length === 0) throw new Error("Add at least one image or attachment.");

Â  Â  showStatus("Generating PDF and output files...", "info");

Â  Â  const vessel = document.getElementById('vesselName').value.trim();
Â  Â  const antenna = document.getElementById('antennaModel').value.trim();
Â  Â  const location = document.getElementById('antennaLocation').value.trim().toUpperCase();
Â  Â  const caseNum = document.getElementById('caseNumber').value.trim();
Â  Â  const submitted = formatSubmittedby(document.getElementById('submittedBy').value.trim());
Â  Â  const dateStr = document.getElementById('dateField').value;
Â  Â  const perPage = parseInt(document.getElementById('imagesPerPage').value);
Â  Â  const compressionQuality = parseFloat(document.getElementById('compressionLevel').value);

Â  Â  const pdf = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a4' });
Â  Â  const pageWidth = pdf.internal.pageSize.getWidth();
Â  Â  const pageHeight = pdf.internal.pageSize.getHeight();

Â  Â  const logoUrl = 'https://raw.githubusercontent.com/pgarciafer/pics2PDF/main/logo.png';
Â  Â  const logo = await loadImage(logoUrl);
Â  Â  if (logo) {
Â  Â  Â  const logoWidth = 350;
Â  Â  Â  const logoHeight = (logo.height * logoWidth) / logo.width;
Â  Â  Â  pdf.addImage(logo, 'PNG', (pageWidth - logoWidth) / 2, 50, logoWidth, logoHeight);
Â  Â  }

Â  Â  pdf.setFontSize(26).setFont('helvetica', 'bold');
Â  Â  pdf.text(vessel, pageWidth / 2, 250, { align: 'center' });
Â  Â  pdf.setFontSize(18);
Â  Â  pdf.text(`${antenna} (${location})`, pageWidth / 2, 290, { align: 'center' });
Â  Â  pdf.setFontSize(14);
Â  Â  pdf.text(`Case Number: ${caseNum}`, pageWidth / 2, 330, { align: 'center' });
Â  Â  pdf.text(`Submitted By: ${submitted}`, pageWidth / 2, 360, { align: 'center' });
Â  Â  pdf.text(`Date: ${dateStr}`, pageWidth / 2, 385, { align: 'center' });

Â  Â  if (images.length > 0) {
Â  Â  Â  pdf.addPage();
Â  Â  Â  let pageNum = 2;
Â  Â  Â  for (let i = 0; i < images.length; i += perPage) {
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Asynchronous PDF page generation
Â  Â  Â  Â  const pageCount = Math.ceil(images.length / perPage);
Â  Â  Â  Â  const currentPage = (i / perPage) + 1;
Â  Â  Â  Â  showStatus(`Processing PDF page ${currentPage} of ${pageCount}...`, 'info');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Pause for UI update
Â  Â  Â  Â  await new Promise(res => setTimeout(res, 0));Â 

Â  Â  Â  Â  const chunk = images.slice(i, i + perPage);
Â  Â  Â  Â  const spacingX = 10, spacingY = 10;
Â  Â  Â  Â  const cellWidth = (pageWidth - (perPage + 1) * spacingX) / perPage;
Â  Â  Â  Â  const cellHeight = pageHeight - 2 * spacingY;

Â  Â  Â  Â  const processedChunk = [];
Â  Â  Â  Â  let maxImageBottom = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const anyCommentInChunk = chunk.some(d => d.comment && d.comment.trim() !== '');
Â  Â  Â  Â  const reservedCommentSpace = anyCommentInChunk ? 50 : 0;
Â  Â  Â  Â  const imgContainerHeight = cellHeight - reservedCommentSpace;

Â  Â  Â  Â  for (let idx = 0; idx < chunk.length; idx++) {
Â  Â  Â  Â  Â  Â  const imgData = chunk[idx];
Â  Â  Â  Â  Â  Â  // processImageForPdf handles the original file (HEIC or JPG)
Â  Â  Â  Â  Â  Â  const dataUrl = await processImageForPdf(imgData.file, 2000, compressionQuality);
Â  Â  Â  Â  Â  Â  if (!dataUrl) continue;

Â  Â  Â  Â  Â  Â  const img = new Image();
Â  Â  Â  Â  Â  Â  img.src = dataUrl;
Â  Â  Â  Â  Â  Â  await new Promise(res => { img.onload = res; });
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const cellAspect = cellWidth / imgContainerHeight;
Â  Â  Â  Â  Â  Â  const imgAspect = img.width / img.height;
Â  Â  Â  Â  Â  Â  let finalW, finalH;

Â  Â  Â  Â  Â  Â  if (imgAspect > cellAspect) {
Â  Â  Â  Â  Â  Â  Â  Â  finalW = cellWidth * 0.95;
Â  Â  Â  Â  Â  Â  Â  Â  finalH = finalW / imgAspect;
Â  Â  Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  Â  Â  Â  finalH = imgContainerHeight * 0.95;
Â  Â  Â  Â  Â  Â  Â  Â  finalW = finalH * imgAspect;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  const cellX = spacingX + idx * (cellWidth + spacingX);
Â  Â  Â  Â  Â  Â  const cellY = spacingY;

Â  Â  Â  Â  Â  Â  const imgX = cellX + (cellWidth - finalW) / 2;
Â  Â  Â  Â  Â  Â  const imgY = cellY + (imgContainerHeight - finalH) / 2;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const imageBottom = imgY + finalH;
Â  Â  Â  Â  Â  Â  if (imageBottom > maxImageBottom) {
Â  Â  Â  Â  Â  Â  Â  Â  maxImageBottom = imageBottom;
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  processedChunk.push({
Â  Â  Â  Â  Â  Â  Â  Â  dataUrl,
Â  Â  Â  Â  Â  Â  Â  Â  comment: imgData.comment,
Â  Â  Â  Â  Â  Â  Â  Â  imgX, imgY, finalW, finalH,
Â  Â  Â  Â  Â  Â  Â  Â  cellX, cellWidth
Â  Â  Â  Â  Â  Â  });
Â  Â  Â  Â  }

Â  Â  Â  Â  const textY = maxImageBottom > 0 ? maxImageBottom + 15 : imgContainerHeight + 15;

Â  Â  Â  Â  for (const pImg of processedChunk) {
Â  Â  Â  Â  Â  Â  pdf.addImage(pImg.dataUrl, "JPEG", pImg.imgX, pImg.imgY, pImg.finalW, pImg.finalH);

Â  Â  Â  Â  Â  Â  if (pImg.comment && pImg.comment.trim() !== '') {
Â  Â  Â  Â  Â  Â  Â  Â  pdf.setFontSize(10).setFont('helvetica', 'normal');
Â  Â  Â  Â  Â  Â  Â  Â  const textLines = pdf.splitTextToSize(pImg.comment, pImg.cellWidth * 0.9);
Â  Â  Â  Â  Â  Â  Â  Â  pdf.text(textLines, pImg.cellX + pImg.cellWidth / 2, textY, { align: 'center' });
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  pdf.setFontSize(12).text(`Page ${pageNum}`, pageWidth / 2, pageHeight - 10, { align: 'center' });
Â  Â  Â  Â  if (i + perPage < images.length) pdf.addPage();
Â  Â  Â  Â  pageNum++;
Â  Â  Â  }
Â  Â  }

Â  Â  if (attachments.length > 0) {
Â  Â  Â  showStatus('Adding attachments...', 'info');
Â  Â  Â  await new Promise(res => setTimeout(res, 0));
Â  Â  Â  pdf.addPage();
Â  Â  Â  pdf.setFontSize(16).setFont('helvetica', 'bold');
Â  Â  Â  pdf.text("Attached Files", pageWidth / 2, 30, { align: 'center' });
Â  Â  Â  pdf.setFontSize(12).setFont('helvetica', 'normal');
Â  Â  Â  let startY = 60;
Â  Â  Â  for (const att of attachments) {
Â  Â  Â  Â  pdf.text(`ğŸ“ ${att.name}`, 20, startY);
Â  Â  Â  Â  startY += 25;
Â  Â  Â  Â  if (startY > pageHeight - 40) {
Â  Â  Â  Â  Â  pdf.addPage();
Â  Â  Â  Â  Â  startY = 40;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }

Â  Â  let pdfBlob = pdf.output('blob');

Â  Â  const compressPdfCheckbox = document.getElementById('compressPdf');
Â  Â  if (compressPdfCheckbox.checked) {
Â  Â  Â  Â  if (ILOVEPDF_PUBLIC_KEY === 'YOUR_PUBLIC_KEY_HERE' || !ILOVEPDF_PUBLIC_KEY) {
Â  Â  Â  Â  Â  Â  throw new Error('Please enter your iLovePDF public key in the script to enable compression.');
Â  Â  Â  Â  }
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  const originalSize = (pdfBlob.size / 1024 / 1024).toFixed(2);
Â  Â  Â  Â  Â  Â  showStatus(`PDF generated (${originalSize} MB). Now compressing...`, 'info');
Â  Â  Â  Â  Â  Â  pdfBlob = await compressPdfWithILovePdf(pdfBlob, ILOVEPDF_PUBLIC_KEY);
Â  Â  Â  Â  Â  Â  const compressedSize = (pdfBlob.size / 1024 / 1024).toFixed(2);
Â  Â  Â  Â  Â  Â  showStatus(`Compression complete! Size reduced from ${originalSize} MB to ${compressedSize} MB.`, 'success');
Â  Â  Â  Â  Â  Â  await new Promise(res => setTimeout(res, 2000));
Â  Â  Â  Â  } catch (compressionError) {
Â  Â  Â  Â  Â  Â  console.error("PDF compression failed:", compressionError);
sÂ  Â  Â  Â  Â  Â  showStatus(`PDF compression failed: ${compressionError.message}. Using uncompressed PDF.`, 'error');
Â  Â  Â  Â  Â  Â  await new Promise(res => setTimeout(res, 3000));
Â  Â  Â  Â  }
Â  Â  }

Â  Â  const pdfFilename = `${vessel}_PicArray_${antenna}_${location.replace(/ /g, '')}_Case${caseNum}_${dateStr.replace(/-/g,'')}.pdf`;
Â  Â Â 
Â  Â  if (attachments.length > 0) {
Â  Â  Â  showStatus('Compressing files into ZIP...', 'info');
Â  Â  Â  await new Promise(res => setTimeout(res, 0));
Â  Â  Â  const zip = new JSZip();
Â  Â  Â  zip.file(pdfFilename, pdfBlob);

Â  Â  Â  const attachmentsFolder = zip.folder("attachments");
Â  Â  Â  for (const att of attachments) {
Â  Â  Â  Â  attachmentsFolder.file(att.name, att);
Â  Â  Â  }

Â  Â  Â  const zipFilename = pdfFilename.replace('.pdf', '.zip');
Â  Â  Â  zip.generateAsync({ type: "blob" }).then(content => {
Â  Â  Â  Â  saveAs(content, zipFilename);
Â  Â  Â  Â  showStatus('PDF and ZIP generated successfully!', 'success');
Â  Â  Â  });
Â  Â  } else {
Â  Â  Â  function isMobile() {
Â  Â  Â  Â  return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
Â  Â  Â  }

Â  Â  Â  if (isMobile() && images.length > 0) {
Â  Â  Â  Â  showStatus('Generating PDF for preview...', 'info');
Â  Â  Â  Â  await new Promise(res => setTimeout(res, 0));
Â  Â  Â  Â Â 
Â  Â  Â  Â  const blobUrl = URL.createObjectURL(pdfBlob);
Â  Â  Â  Â  const previewWindow = window.open('', '_blank');

Â  Â  Â  Â  if (previewWindow) {
Â  Â  Â  Â  Â  previewWindow.document.title = pdfFilename;
Â  Â  Â  Â  Â  previewWindow.document.body.style.margin = '0';
Â  Â  Â  Â  Â  previewWindow.document.body.style.overflow = 'hidden';
Â  Â  Â  Â  Â  const iframe = previewWindow.document.createElement('iframe');
Â  Â  Â  Â  Â  iframe.src = blobUrl;
Â  MÂ  Â  Â  Â  Â  iframe.style.width = '100vw';
Â  Â  Â  Â  Â  iframe.style.height = '100vh';
Â  Â  Â  Â  Â  iframe.style.border = 'none';
Â  Â  Â  Â  Â  previewWindow.document.body.appendChild(iframe);
Â  Â  Â  Â  Â  showStatus('PDF generated! Check the new tab to view or share.', 'success');
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  showStatus('Popup blocked. Downloading PDF directly.', 'error');
Â  Â  s Â  Â  Â  saveAs(pdfBlob, pdfFilename);
Â  Â  Â  Â  }
Â  Â  Â  } else {
Â  Â  Â  Â  showStatus('Saving PDF...', 'info');
Â  Â  Â  Â  await new Promise(res => setTimeout(res, 0));
Â  Â  Â  Â  saveAs(pdfBlob, pdfFilename);
Â  Â  Â  Â  showStatus('PDF generated successfully!', 'success');
Â  Â  Â  }
Â  Â  }

Â  } catch (err) {
Â  Â  showStatus(err.message || "Error generating PDF/ZIP.", "error");
s Â  console.error(err);
Â  } finally {
Â  Â  generateBtn.disabled = false;
Â  Â  generateBtn.classList.remove('loading');
Â  }
});


function loadImage(src){
Â  return new Promise(res=>{
Â  Â  const img=new Image();
Â  Â  img.crossOrigin='Anonymous';
Â  Â  img.src=src;
Â  Â  img.onload=()=>res(img);
Â  Â  img.onerror=()=>res(null);
Â  });
}

// === Drag and Drop Functions (Desktop) ===
function handleDragStart(e) {
s Â  this.classList.add('dragging');
Â  dragSrcEl = this;
Â  e.dataTransfer.effectAllowed = 'move';
Â  e.dataTransfer.setData('text/plain', this.dataset.id);
}

function handleDragOver(e) {
Â  if (e.preventDefault) {
Â  Â  e.preventDefault();
Â  }
Â  e.dataTransfer.dropEffect = 'move';
Â  return false;
}

function handleDragEnter(e) {
Â  if (this !== dragSrcEl) {
Â  Â  this.classList.add('over');
Â  }
}

function handleDragLeave(e) {
Â  this.classList.remove('over');
}

function handleDrop(e) {
Â  if (e.stopPropagation) {
Â  Â  e.stopPropagation();
Â  }
Â Â 
Â  if (dragSrcEl !== this) {
Â  Â  const allItems = Array.from(imageListContainer.children);
Â  Â  const srcIndex = allItems.indexOf(dragSrcEl);
Â  Â  const targetIndex = allItems.indexOf(this);

Â  Â  if (srcIndex < targetIndex) {
Â  Â  s Â  Â  imageListContainer.insertBefore(dragSrcEl, this.nextSibling);
Â  Â  } else {
Â  Â  Â  Â  imageListContainer.insertBefore(dragSrcEl, this);
Â  Â  }
Â  }
Â  return false;
}

function handleDragEnd(e) {
Â  const items = document.querySelectorAll('.image-list-container .image-wrapper');
Â  items.forEach(function (item) {
Â  Â  item.classList.remove('over');
Â  Â  item.classList.remove('dragging');
Â  });

Â  // Re-sync the `images` array with the new DOM order
Â  const newDomOrder = [...imageListContainer.children];
Â  const newImagesArray = newDomOrder
Â  Â  .map(wrapper => images.find(img => img.id === wrapper.dataset.id))
Â  Â  .filter(Boolean); // Filter out any undefined if something went wrong
Â  images = newImagesArray;
Â Â 
Â  dragSrcEl = null;
}

// === Touch Drag and Drop Functions (Mobile) ===
let touchDragEl = null, isDraggingTouch = false, placeholder = null, longPressTimer = null;
let initialTouchX = 0, initialTouchY = 0, startRect = null;
const LONG_PRESS_DURATION = 300; // ms

function handleTouchStart(e) {
Â  if (e.target.classList.contains('remove-image-btn')) return;

Â  touchDragEl = this;
Â  const touch = e.touches[0];
Â  const startX = touch.clientX;
s Â  const startY = touch.clientY;

Â  const cancelDrag = () => {
Â  Â  clearTimeout(longPressTimer);
Â  Â  document.removeEventListener('touchmove', onMove);
Â  Â  document.removeEventListener('touchend', cancelDrag);
Â  Â  document.removeEventListener('touchcancel', cancelDrag);
Â  };

Â  const onMove = (moveEvent) => {
Â  Â  const moveTouch = moveEvent.touches[0];
Â  Â  // If finger moves more than 10px, it's a scroll, not a long press.
Â  Â  if (Math.abs(moveTouch.clientX - startX) > 10 || Math.abs(moveTouch.clientY - startY) > 10) {
Â  Â  Â  cancelDrag();
Â  Â  }
Â  };
Â Â 
Â  document.addEventListener('touchmove', onMove);
Â  document.addEventListener('touchend', cancelDrag);
Â  document.addEventListener('touchcancel', cancelDrag);

Â  longPressTimer = setTimeout(() => {
Â  Â  cancelDrag(); // We are starting the drag, so these listeners are no longer needed.

Â  Â  isDraggingTouch = true;
s Â  Â  startRect = touchDragEl.getBoundingClientRect();
Â  Â  initialTouchX = touch.clientX;
Â  Â  initialTouchY = touch.clientY;
Â  Â Â 
Â  Â  placeholder = document.createElement('div');
Â  Â  placeholder.classList.add('placeholder');
Â  Â  placeholder.style.width = `${startRect.width}px`;
Â  Â  placeholder.style.height = `${startRect.height}px`;
Â  Â  touchDragEl.parentNode.insertBefore(placeholder, touchDragEl);

Â  Â  Object.assign(touchDragEl.style, {
Â  Â  Â  Â  position: 'fixed',
Â  Â  Â  Â  zIndex: '1000',
Â  Â  Â  Â  width: `${startRect.width}px`,
Â  A Â  Â  Â  height: `${startRect.height}px`,
Â  Â  Â  Â  left: `${startRect.left}px`,
Â  Â  Â  Â  top: `${startRect.top}px`,
Â  Â  Â  Â  margin: '0'
Â  Â  });
Â  Â  touchDragEl.classList.add('touch-dragging');

Â  Â  document.addEventListener('touchmove', handleTouchMove, { passive: false });
Â  Â  document.addEventListener('touchend', handleTouchEnd);
Â  Â  document.addEventListener('touchcancel', handleTouchEnd);
Â  }, LONG_PRESS_DURATION);
}

function handleTouchMove(e) {
Â  if (!isDraggingTouch) return;
Â  e.preventDefault();

Â  const touch = e.touches[0];
Â  const dx = touch.clientX - initialTouchX;
Â  const dy = touch.clientY - initialTouchY;

Â  touchDragEl.style.transform = `translate(${dx}px, ${dy}px)`;

Â  touchDragEl.style.visibility = 'hidden';
Â  const elementBelow = document.elementFromPoint(touch.clientX, touch.clientY);
Â  touchDragEl.style.visibility = 'visible';

Â  if (!elementBelow) return;

Â  const dropTarget = elementBelow.closest('.image-wrapper');
Â  if (dropTarget && dropTarget !== touchDragEl && dropTarget !== placeholder) {
Â  Â  Â  const dropTargetRect = dropTarget.getBoundingClientRect();
Â  Â  Â  const isAfter = (touch.clientX > dropTargetRect.left + dropTargetRect.width / 2);

Â  Â  Â  if (isAfter) {
Â  Â  Â  Â  Â  dropTarget.parentNode.insertBefore(placeholder, dropTarget.nextSibling);
Â  Â  Â  } else {
Â  Â  Â  Â  Â  dropTarget.parentNode.insertBefore(placeholder, dropTarget);
Â  Â  Â  }
Â  }
}

function handleTouchEnd(e) {
Â  if (!isDraggingTouch) return;

Â  document.removeEventListener('touchmove', handleTouchMove);
DÂ  document.removeEventListener('touchend', handleTouchEnd);
Â  document.removeEventListener('touchcancel', handleTouchEnd);

Â  if (touchDragEl && placeholder) {
Â  Â  placeholder.parentNode.insertBefore(touchDragEl, placeholder);
Â  Â  placeholder.remove();
Â  Â Â 
Â  Â  touchDragEl.classList.remove('touch-dragging');
Â  Â  touchDragEl.style.cssText = ''; // Resets all inline styles
Â  }
Â Â 
Â  // Re-sync the `images` array with the new DOM order
Â  const newDomOrder = [...imageListContainer.children];
Â  const newImagesArray = newDomOrder
Â  Â  .map(wrapper => images.find(img => img.id === wrapper.dataset.id))
Â  Â  .filter(Boolean); // Filter out any undefined if something went wrong
Â  images = newImagesArray;
Â Â 
Â  isDraggingTouch = false;
Â  touchDragEl = null;
Â  placeholder = null;
Â  startRect = null;
}

// === NEW: Add listeners for auto-saving form data ===
jobInfoInputIds.forEach(id => {
s Â  document.getElementById(id).addEventListener('input', saveFormToLocalStorage);
});

// === NEW: Load saved form data on page load ===
document.addEventListener('DOMContentLoaded', loadFormFromLocalStorage);
</script>
</body>
</html>
